#!/usr/bin/env perl
#
#

use v5.14;
use strict;
use warnings;

use Mojo::DOM;
use JSON;
use Imager;
use IO::All;

use G0cr::Config;
use G0cr::ElasticSearch;

sub cut_word_from_hocr {
    my ($hocr_file_name, $image_file_name, $output_dir) = @_;

    my $hocr = {};

    my $hocr_dom = Mojo::DOM->new( scalar io($hocr_file_name)->utf8->all );
    my @capabilities = split " ", $hocr_dom->find("meta[name=ocr-capabilities]")->first->attr("content");
    for my $capability (@capabilities) {
        my @all_bbox;
        $hocr_dom->find("body .${capability}")->each(
            sub {
                my $el = shift;
                return if $el->children->size > 0;
                my (undef, @bbox) = split(" ", $el->attr("title"));
                push @all_bbox, {
                    id => $el->attr("id"),
                    bbox => \@bbox,
                    text => $el->all_text(0),
                }
            }
        );
        $hocr->{$capability} = \@all_bbox;
    }

    my $image = Imager->new( file => $image_file_name ) or die Imager->errstr;
    for my $c (keys %$hocr) {
        my $bbox = $hocr->{$c};
        for (@$bbox) {
            my $id = $_->{id};
            my $bbox = $_->{bbox};
            my $bbox_csv = join ",",@$bbox;
            my $box_image = $image->crop( left => $bbox->[0], top => $bbox->[1], right => $bbox->[2], bottom => $bbox->[3] ) or next;
            $box_image->write( file => "${output_dir}/${bbox_csv}.png" );
        }
    }

    return $hocr;
}

sub convert_pages_to_png {
    my $req = shift;

    my ($source_file) = io->dir($req->{config}{storage}, $req->{sha1})->glob("source.*");
    unless ($source_file->exists) {
        say "source file does not exists: $source_file\n";
        return 0;
    }
    say "processing $source_file";

    my $output_dir = io->catdir($req->{config}{storage}, $req->{sha1}, "page");
    $output_dir->mkdir unless $output_dir->exists;
    unless ((my $done = io->catfile($output_dir, ".done_convert"))->exists) {
        say "processing $output_dir";

        my $base_name  = $output_dir->catfile("page.png");
        system('convert', -density => 300, $source_file, $base_name) == 0 or (return 0);

        my @pages = <$output_dir/page-*.png>;
        if (!@pages && $base_name->exists) {
            $base_name->rename( $output_dir->catfile("page-1.png") );
            @pages = <$output_dir/page-*.png>;
        }

        for my $page (@pages) {
            my $page_base_dir = substr($page,0,-4);
            my $page_name = io->file($page)->filename;
            mkdir($page_base_dir);
            rename $page, io->catfile($page_base_dir, "page.png");
        }
        $done->assert->touch;
    }

    return 1;
}

sub tesseract_pages {
    my $req = shift;
    my $output_dir = io->catdir($req->{config}{storage}, $req->{sha1}, "page");
    $output_dir->mkdir unless $output_dir->exists;
    unless ((my $done = io->catfile($output_dir, ".done_tesseract"))->exists) {
        system(qw(parallel tesseract {} {.} -l chi_tra hocr ::: ), <$output_dir/page-*/page.png>) == 0 or return 0;
        $done->touch;
    }

    my $bbox = {};
    if ((my $done = io->catfile($output_dir, ".done_cutword"))->exists) {
        $bbox = JSON->new->utf8->decode(io->catfile($output_dir, "cutword.json")->all );
    } else {
        for my $page_dir (<$output_dir/page-*>) {
            my ($page_name) = $page_dir =~ m{\/([^/]+?)\z};
            $bbox->{$page_name} = cut_word_from_hocr("${page_dir}/page.html", "${page_dir}/page.png", $page_dir);
        }

        io->catfile($output_dir, "cutword.json")->print( JSON->new->utf8->pretty->encode($bbox) );

        $done->touch;
    }

    return $bbox;
}

sub store_hocr_in_index {
    my ($es, $sha1, $hocr_pages) = @_;
    say "indexing $sha1";

    my @ocr_text;
    for my $page_number (keys %$hocr_pages) {
        my $n = 0+ substr($page_number,5); # assuming it matches /\A page-\d+ \z/

        for my $ocr_type (keys %{ $hocr_pages->{$page_number} }) {
            for my $x (@{ $hocr_pages->{$page_number}{$ocr_type} }) {
                push @ocr_text, {
                    text => $x->{text},
                    bbox => $x->{bbox},
                    bbox_csv => join(",",@{$x->{bbox}}),
                    page_number => $n,
                    hocr_type => $ocr_type,
                    hocr_id => $x->{id},
                };
            }
        }
    }
    if (@ocr_text) {
        my ($status, $res) = $es->post(
            index => "g0cr",
            type => "document",
            id => $sha1,
            command => "_update",
            body => {
                doc => {
                    tesseract_done => (sub{
                                      my @t = gmtime(time);
                                      $t[5] += 1900;
                                      $t[4] += 1;
                                      return sprintf("%4d%02d%02dT%02d%02d%02dZ",@t[5,4,3,2,1,0])
                                  }->()),
                    tesseract_output => \@ocr_text
                }
            }
        );
        if ($status !~ /\A2/) {
            print Data::Dumper::Dumper([ ERROR => $res ]);
        } else {
            say "Update $sha1 success";
        }
    }
    return 1;
}

sub main {
    my $config = G0cr::Config->load;
    say $config->{storage};
    my $es = G0cr::ElasticSearch->new;
    my $res = $es->search_unprocessed;
    for (@{ $res->{hits}{hits} }) {
        my $req = {
            sha1 => (my $sha1 = $_->{_source}{sha1}),
            config => $config,
        };
        say $sha1;
        convert_pages_to_png( $req ) or next;
        my $hocr_pages = tesseract_pages( $req ) or next;
        store_hocr_in_index($es, $sha1, $hocr_pages);
    }
}

main();

